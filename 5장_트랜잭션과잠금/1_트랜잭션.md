# 5. 트랜잭션과 잠금

### 트랜잭션

> **작업의 완전성을 보장해주는 기능**
> 
- **논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구함으로써 작업의 일부만 적용되는 현상 (Partial update) 이 발생하지 않도록 하는 기능**

### 잠금

> **동시성을 제어하기 위한 기능**
> 
- **여러 커넥션에서 동시에 동일한 자원 (레코드나 테이블)을 요청할 경우, 순서대로 한 시점에는 하나의 커넥션만 자원을 변경할 수 있도록 해주는 역할을 하는 기능**

<br>

> [!IMPORTANT]
> 
> **트랜잭션** : 데이터의 정합성을 보장하기 위한 기능
> 
> **잠금** : 동시성을 제어하기 위한 기능

<br>

## 5.1 트랜잭션

### 5.1.1 MySQL 에서의 트랜잭션

**트랜잭션**

> 하나의 **논리적인 작업 셋**에 하나의 쿼리가 있든, 두 개의 쿼리가 있든 관계없이 **논리적인 작업 셋** 자체가 100% 적용되거나 (COMMIT 을 실행했을 때) 아무것도 적용되지 않아야 (ROLLBACK 또는 트랜잭션을 ROLLBACK 시키는 오류가 발생했을 때) 함을 보장해주는 것

<br>

**MySQL 서버의 여러 스토리지 엔진들**

- MyISAM & MEMORY 스토리지 엔진 : 트랜잭션 지원 X
- InnoDB 스토리지 엔진 : 트랜잭션 지원 O

MySQL 서버에는 여러 스토리지 엔진들이 존재하는데, 모든 스토리지 엔진이 트랜잭션 기능을 지원하지는 않는다. 

그럼 트랜잭션 기능 지원 여부에 따라 어떻게 다르게 동작하는지를 한 번 알아보자.

1. **테스트용 테이블 생성 및 레코드 1건(pk = 3) 씩 저장**

```sql
CREATE TABLE tab_myisam ( 
							fdpk INT NOT NULL,
							PRIMARY KEY (fdpk)
) ENGINE = MyISAM;

INSERT INTO tab_myisam (fdpk) VALUES (3);

----------------------------------------------

CREATE TABLE tab_innodb ( 
							fdpk INT NOT NULL,
							PRIMARY KEY (fdpk)
) ENGINE = INNODB;

INSERT INTO tab_innodb (fdpk) VALUES (3);
```

2. **AUTO-COMMIT 모드에서 쿼리 실행**

```sql
SET autocommit=ON;

INSERT INTO tab_myisam (fdpk) VALUES (1),(2),(3);
INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);
```

3. **각각의 테이블에 중복된 PK 값 INSERT 쿼리 실행 및 오류 발**

```sql
INSERT INTO tab_myisam (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

-----------------------------------------------------------

SELECT * FROM tab_myisam;

+-----+
| fdpk|
+-----+
|  1  |
|  2  |
|  3  |
+-----+

-----------------------------------------------------------

SELECT * FROM tab_innodb;

+-----+
| fdpk|
+-----+
|  3  |
+-----+

```

<br>

> [!IMPORTANT]
> 
> **MyISAM 스토리지 엔진의 동작 VS InnoDB 스토리지 엔진의 동작**
> ---
>
> - **MyISAM 스토리지 엔진 사용 경우 - 트랜잭션 지원 X**
>     - INSERT 문장이 실행되면서 차례대로 ‘1’, ‘2’ 를 저장함
>     - 그 다음 ‘3’ 을 저장하려고 하는 순간 중복 키 오류가 발생
>     - 트랜잭션을 지원하지 않기 때문에 이미 INSERT 된 ‘1’, ‘2’ 는 그대로 유지
>    
>     → **부분 업데이트 (Partial Update)** 발생. 테이블 데이터의 정합성을 맞추는 데 큰 어려움을 만드는 문제점
>     
> - **InnoDB 스토리지 엔진 사용 경우 - 트랜잭션 지원 O**
>     - INSERT 문장이 실행되면서 ‘1’, ‘2’ 를 저장함
>     - 그 다음 ‘3’ 을 저장하려고 하는 순간 중복 키 오류가 발생
>     - 트랜잭션을 지원하기 때문에 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 복구한다는 트랜잭션의 원칙에 따라 INSERT 문장을 실행하기 전 상태로 복구


<br>

**애플리케이션 개발 관점에서 부분 업데이트 문제 대응은 어떻게 해야할까?**

1. **트랜잭션을 지원하지 않는 경우**
    
    ```sql
    INSERT INTO tab_a ...;
    
    IF(_is_insert1_succeed) {
    		INSERT INTO tab_b ...;
    		
    		IF(_is_insert2_succeed) {
    			// 처리 완료
    		} ELSE {
    				DELETE FROM tab_a WHERE ...;
    				
    				IF(_is_delete_succeed) {
    					// 처리 실패 및 tab_a, tab_b 모두 원상 복구 완료
    				ELSE {
    					// 해결 불가능한 심각한 상황 발생
    						
    					// 이제 어떻게 해야할까? tab_b 에 insert 는 실패했고, 
    					// 그렇다고 tab_a 에 insert 된 데이터를 삭제해서 원상복구하자니 원상복구도 실패하는 상황
    ```
    
    - 쿼리문의 성공 여부를 확인하고, 실패하는 경우에는 원상복구 할 수 있는 로직을 매 분기문마다 작성해줄 필요가 생김

2. **트랜잭션을 지원하는 경우**
    
    ```sql
    try {
    	START TRANSACTION;
    	
    	INSERT INTO tab_a ...;
    	INSERT INTO tab_b ...;
    	
    	COMMIT;
    } catch(exception) {
    	ROLLBACK;
    }
    ```
    
    - 트랜잭션이 지원되는 경우 쿼리문 각각의 성공 여부를 개발자가 직접 확인할 필요가 없다. 즉 위처럼 매우 간결하게 코드 작성이 가능해진다.

<br>

### 5.1.2 주의사항

> DBMS 의 커넥션처럼 꼭 필요한 최소의 코드에만 트랜잭션을 적용하는 것이 좋다. 즉 **프로그램 코드에서 트랜잭션의 범위를 최소화하자**
> 

<br>

**예시 - 게시판에 게시물 작성 및 저장 버튼 클릭**

1. **트랜잭션을 넓은 범위에 거는 경우**

```
1) 처리 시작
	=> 데이터베이스 커넥션 생성
	=> 트랜잭션 시작

2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS 에 저장
6) 첨부 파일 정보를 DBMS 에 저장
7) 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS 에 저장
	<= 트랜잭션 종료 (COMMIT)
	<= 데이터베이스 커넥션 반납

10) 처리 완료
```

**위 처리 절차 중에서 DBMS 의 트랜잭션 처리에 좋지 않은 영향을 미치는 부분들**

- 실제 DBMS 에 데이터를 저장하는 작업(트랜잭션) 은 5번 부터 시작된다. 즉 2, 3, 4 번 절차가 아무리 빨리 처리된다고 하더라도, DBMS 의 트랜잭션에 포함시킬 필요가 없다.
    - 데이터베이스 커넥션은 개수가 제한적이므로 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들게된다.
- 가장 큰 문제는 8번 작업이다. 메일 전송이나 FTP 파일 전송 작업, 혹은 네트워크를 통해 원격 서버와 통신하는 등의 작업은 어떻게 해서든 DBMS 의 트랜잭션 내에서 제거하는 것이 좋다.
    - 원격 서버와 통신할 수 없는 상황이 발생한다면 웹 서버 뿐만 아니라 DBMS 서버까지 위험해지는 상황이 발생한다.
- 위 처리 절차에는 DBMS 의 작업이 크게 4개 존재한다.
    - 사용자가 입력한 정보를 저장하는 **5번 & 6번 작업** → 이 둘은 하나의 트랜잭션으로 묶어야한다.
    - 저장된 데이터의 단순 확인 및 조회인 **7번 작업** → 트랜잭션에 포함시킬 필요가 없다.
    - 알림 메일 발송 이력을 DBMS 에 저장하는 **9번 작업** → 5번 & 6번 작업과 성격이 다르기에 별도의 트랜잭션으로 분리하자.

<br>

2. **보완 - 트랜잭션을 좁은 범위에 거는 경우**

```
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
	=> 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)**
	=> 트랜잭션 시작
5) 사용자의 입력 내용을 DBMS 에 저장
6) 첨부 파일 정보를 DBMS 에 저장
	<= 트랜잭션 종료 (COMMIT)
	
7) 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8) 게시물 등록에 대한 알림 메일 발송
	=> 트랜잭션 시작
9) 알림 메일 발송 이력을 DBMS 에 저장
	<= 트랜잭션 종료 (COMMIT)
	<= 데이터베이스 커넥션 종료(또는 커넥션 풀에 반납)

10) 처리 완료
```

이처럼 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화하자.

또한 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.

