애플리케이션에서 입력된 데이터를 데이터베이스에 저장하거나 데이터를 가져오려면 SQL을 사용해야함

- DDL (Data Definition Language): 데이터베이스나 테이블의 구조를 변경하기 위한 문장
- DML (Data Manipulation Language): 테이블의 데이터를 조작하기 위한 문장

SQL 처리에서 "어떻게'를 이해하고 쿼리를 작성해야 효과적인 성능 개선을 이룰 수 있음

# 11.1.1 SQL 모드

`sql_mode`라는 시스템 설정을 통해 SQL의 작성과 결과에 영향을 미치는 값을 설정 가능

> [!CAUTION]
>
> sql_mode 시스템 변수에 설정된 값은 SQL 문장 작성 규칙과 MySQL 서버 내부적 옵션도 함께 있기 때문에 MySQL 서버에 사용자 테이블 생성 및 저장을 시작한 이후에는 변경하지 않는 것이 좋음

- `sql_mode` 기본 값 옵션

  - `STRICT_ALL_TABLES & STRICT_TRANS_TABLES` : MySQL 서버에서는 INSERT나 UPDATE 문장으로 데이터를 변경하는 경우, 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행함. 이때, 적절한 타입 변환이 어렵거나 값의 길이가 칼럼의 최대 길이보다 큰 경우 MySQL 서버가 계속 문장을 실행할지 에러를 발생시킬지 결정

    - `STRICT_ALL_TABLES`: InnoDB와 같이 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용
    - `STRICT_TRANS_TABLES`: 트랜잭션 지원 여부와 무관하게 모든 스토리지 엔진에 대해 엄격한 모드 적용

    > 이 두 옵션은 사용자가 원치 않는 값으로 자동 변환이 일어날 수 있기 때문에 MySQL 서버를 서비스에 적용하기 전에 활성화할 것을 권장

  - `ANSI_QUOTES` : MySQL에서는 문자열 값을 표현하기 위해 홑따옴표와 쌍따옴표 동시에 사용 가능함. 오라클과 같은 DBMS에서는 홑따옴표를 문자열 값 표기에 사용하고 쌍따옴표는 칼럼명과 같은 식별자 구분에 사용

    홑따옴표만 문자열 값 표기로 사용하고, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별자를 표기하는 데만 사용 가능

  - `PIPE_AS_CONCAT` : MySQL에서 "||"는 OR 연산자의 의미로 사용되지만 해당 값을 사용하면 오라클과 같이 CONCAT(문자열 연결 연산자)로 사용 가능

  - `PAD_CHAR_TO_FULL_LENGTH` : MySQL에서 CHAR 타입이라도 VARCHAR와 같이 유효 문자열 뒤의 공백 문자는 제거되어 반환됨. 만약 이를 원치 않는다면 해당 값을 추가하면 됨

  - `NO_BACKSLASH_ESCAPES` : MySQL에서 역슬래시 문자를 이스케이프 문자로 사용 가능하나 해당 값을 추가하면 역슬래시 문자도 **다른 문자와 동일하게 취급**

  - `IGNORE_SPACE` : MySQL에서는 스토어드 프로시저의 함수명과 괄호 사이에 있는 공백까지도 스토어드 프로시저나 함수의 이름으로 간주함. 해당 값을 추가하면 프로시저나 함수명과 괄호 사이의 공백을 무시함

    - 해당 옵션은 MySQL 서버의 내장 함수에만 적용
    - 옵션 활성화 시, MySQL의 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용 불가능

      +) 역따옴표를 이용하면 가능

  - `REAL_AS_FLOAT`: MySQL에서 부동 소수점 타입은 FLOAT, DOUBLE 타입이 지원되고 REAL 타입은 DOUBLE 타입의 동의어로 사용됨. 해당 옵션 활성화 시 REAL 타입이 FLOAT 타입의 동의어로 바뀜

  - `NO_ZERO_IN_DATE & NO_ZERO_DATE`: 두 옵션 활성화 시 MySQL 서버는 "2025-00-00"과 같은 잘못된 날짜 지정 불가능. 실제 존재하지 않은 날짜를 저장하지 못하게 하려면 해당 옵션 활성화

  - `ANSI`: 여러 옵션을 조합해서 MySQL 서버가 최대한 SQL 표준에 맞게 동작하게 만들어줌

  "REAL_AS_FLOAT, PIPE_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY" 모드의 조합으로 구성

  - `TRADITIONAL`: `STRICT_ALL_TABLES & STRICT_TRANS_TABLES` 이 두 옵션과 비슷하나 조금 더 엄격하게 작동함.

  "STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION" 모드의 조합으로 구성

  해당 옵션 활성화 시 경고로 처리되던 상황이 모두 에러로 바뀌고 SQL 문장 실패

# 11.1.2 영문 대소문자 구분

설치된 운영체제에 따라 테이블의 대소문자를 구분함

- Window: 대소문자 구분 X
- Unix 계열: 대소문자 구분

-> 대소문자 구분의 영향을 받지 않게 하려면 MySQL 서버의 설정 파일에 `lower_case_table_name` 시스템 변수 설정

- 1로 설정: 모두 소문자로 저장 & 대소문자 구분 X
- 0으로 설정 (기본값): DB나 테이블명에 대해 대소문자 구분
- 2로 설정 (윈도우와 macOS): 저장은 대소문자 구분 & MySQL 쿼리에서는 대소문자 구분 X

# 11.1.3 MySQL 예약어

## 예약어 사용의 한계점

생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어로 생성 시 역따옴표나 쌍따옴표로 감싸야해서 번거로움

또, 예약어를 사용하면 단순히 '문법 오류' 형식의 에러만 출력되어 버그의 원인을 찾기가 쉽지 않음

## 대처 방안

테이블 직접 생성: 역따옴표로 감싸지 않고 테이블이나 칼럼을 생성

- 성공 시, 해당 예약어는 예약어이지만 사용해도 문제가 되지 않는 예약어
- 에러 발생 시, 해당 예약어는 반드시 역따옴표로 감싸야만 사용 가능한 예약어

## 예시

MySQL에 데이터 정렬을 지시하는 예약어인 ORDER(BY)가 존재함

만약 order라는 이름을 가진 item 테이블을 생성한 경우, MySQL은 order를 칼럼 이름이 아닌 SQL 명령어로 해석하려 해서 에러가 발생함

- 칼럼 생성: `CREATE TABLE item (order INT);`
- 데이터 조회: `SELECT order FROM item;`

-> 오류 발생

예약어를 이름으로 사용하려면 MySQL에게 예약어가 아니고 식별자임을 알려줘야하는데 이 때 **역따옴표**를 사용

- CREATE TABLE item (`order` INT);

예약어를 이름으로 사용할 때마다 매번 역따옴표로 감싸는 것은 번거로움

그렇기 때문에 예약어인지 아닌지 헷갈릴 때, **역따옴표 없이 테이블 생성**
