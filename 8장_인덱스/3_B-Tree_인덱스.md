## 8.3. B-Tree 인덱스

가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘이며, 아직도 가장 범용적인 목적으로 사용되는 인덱스 알고리즘이다. B-Tree에는 여러 변형된 형태가 있는데, 보통 B+-Tree 또는 B*-Tree가 사용된다. B-Tree의 B는 **Balanced**를 의미한다.

### 8.3.1. B-Tree 인덱스의 기본 구조

* B-Tree는 하나의 **루트 노드(Root node)**(최상위)와 다수의 **리프 노드(Leaf node)**(최하위)로 구성된다.
* 루트도 리프도 아닌 중간 노드를 **브랜치 노드(Branch node)**라고 한다.
* 데이터베이스에서 인덱스와 실제 데이터는 별도로 관리되며, 인덱스의 **리프 노드**는 실제 데이터 레코드를 찾아가기 위한 **주소값**을 가진다.

### 8.3.2. MyISAM과 InnoDB의 인덱스 구조

B-Tree 인덱스 내의 키 값은 모두 정렬되어 있다. 하지만 대부분의 RDBMS(MyISAM 등)에서 **데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서(Unsorted)**로 저장된다. 레코드가 삭제된 공간을 재사용할 수도 있기 때문이다.

* **예외:** InnoDB 테이블은 **클러스터형(Clustered)**으로 데이터를 저장한다. 이 경우, 데이터 파일 자체가 프라이머리 키(PK) 순서대로 정렬된다.

두 스토리지 엔진의 가장 큰 차이점은 **세컨더리 인덱스(Secondary Index)**가 실제 데이터를 찾는 방식에 있다.

**📈 MyISAM (Non-Clustered Index)**

* **구조:** Non-Clustered Index (데이터와 인덱스가 분리됨).
* **주소값:** 인덱스의 리프 노드가 데이터 레코드의 **물리적인 주소(ROWID 또는 Offset)**를 가진다.
* **검색 방식:** 세컨더리 인덱스를 검색하면, 리프 노드에서 얻은 **물리적 주소**를 이용해 데이터 파일에서 레코드를 **즉시** 찾아낸다.

**📉 InnoDB (Clustered Index)**

* **구조:** Clustered Index (프라이머리 키 기준으로 데이터 파일 자체가 정렬됨).
* **주소값:** 세컨더리 인덱스의 리프 노드는 물리적 주소 대신, 해당 레코드의 **프라이머리 키(PK) 값**을 가진다. (PK를 '논리적 주소'처럼 사용).
* **검색 방식 (세컨더리 인덱스 사용 시):**
    1.  먼저 **세컨더리 인덱스**의 B-Tree를 검색하여 리프 노드에서 **PK 값**을 찾는다. (예: first_name 'Aamer' -> PK 11000)
    2.  이 PK 값을 가지고 **프라이머리 키 인덱스(클러스터형 인덱스)**의 B-Tree를 **다시 한번 검색**한다.
    3.  프라이머리 키 인덱스의 리프 노드(실제 데이터 페이지)에서 최종 레코드를 찾는다.
* **요약:** InnoDB는 세컨더리 인덱스로 데이터를 조회할 때, MyISAM과 달리 B-Tree를 **총 두 번 검색**해야 한다. (세컨더리 인덱스 검색 1회 + 프라이머리 키 인덱스 검색 1회)

### 8.3.3. B-Tree 인덱스 키 연산 (추가, 삭제, 변경, 검색)

#### 1. 인덱스 키 추가 (INSERT)

새로운 레코드가 INSERT 될 때 인덱스 키가 추가된다.
* **저장 과정:**
    1.  새로운 키 값이 저장될 B-Tree의 적절한 위치(리프 노드)를 검색한다.
    2.  리프 노드가 가득 차서 더는 저장할 수 없으면, **노드 분리(Split)**가 발생한다.
    3.  이 분리 작업은 상위 브랜치 노드까지 처리 범위가 넓어질 수 있어, B-Tree는 상대적으로 **쓰기(추가) 작업에 비용이 많이 든다.**
* **스토리지 엔진별 차이:**
    * **MyISAM/MEMORY:** INSERT 문 실행 시 즉시 B-Tree 인덱스를 변경한다.
    * **InnoDB:** 프라이머리 키나 유니크 키의 중복 체크가 필요하므로, 이 작업을 **'체인지 버퍼(Change Buffer)'**를 사용하여 지연시킬 수 있다.

#### 2. 인덱스 키 삭제 (DELETE)

레코드가 DELETE 될 때 인덱스 키가 삭제되며, 과정은 비교적 간단하다.
* **삭제 과정:**
    1.  해당 키 값이 저장된 B-Tree의 리프 노드를 찾는다.
    2.  리프 노드에서 해당 키 값을 **삭제**한다.
    3.  삭제된 인덱스 공간은 재사용되거나 그대로 남아있을 수 있다.
* **스토리지 엔진별 차이:**
    * **MyISAM/MEMORY:** 체인지 버퍼가 없어 즉시 인덱스 키 삭제가 완료된다.
    * **InnoDB (MySQL 5.5 이상):** 이 작업 역시 체인지 버퍼를 통해 지연 처리될 수 있다.

#### 3. 인덱스 키 변경 (UPDATE)

인덱스 키 값 자체가 변경되는 UPDATE의 경우, B-Tree의 키 값 위치가 달라져야 한다.
* **변경 과정:**
    * 기존 키 값을 수정하는 방식(In-place update)은 불가능하다.
    * 대신, **"1. 기존 키 값 삭제"** 후 **"2. 새로운 키 값 추가"**하는 두 단계로 처리된다.
    * 즉, 키 변경 작업은 **삭제(Delete)**와 **추가(Insert)** 작업이 순차적으로 일어나는 것과 동일하다.

#### 4. 인덱스 키 검색 (SELECT, UPDATE, DELETE)

SELECT뿐만 아니라 INSERT, UPDATE, DELETE를 처리할 때도 인덱스를 사용해 레코드를 먼저 검색해야 한다.
* **검색 과정:**
    * 검색은 B-Tree의 **루트 노드**에서 시작해 **브랜치 노드**를 거쳐 최종 **리프 노드**까지 이동하는 **"트리 탐색(Tree Traversal)"** 과정을 거친다.
* **인덱스 활용 조건:**
    * **활용 가능 (O):**
        * 100% 일치하는 값 검색
        * 인덱스 키의 **왼쪽 일부분(Left-most prefix)**과 일치하는 경우 (예: (col1, col2) 인덱스에서 col1만 검색)
        * 부등호(>) 비교 조건
    * **활용 불가능 (X):**
        * 인덱스의 첫 번째 부분이 아닌 중간 부분으로 검색하는 경우
        * 인덱스 키 값이 **변형된(가공된)** 경우 (예: WHERE function(indexed_col) = ...)
        * *이 경우 B-Tree의 장점을 이용하지 못해 성능이 저하된다.*
* **InnoDB의 주의점 (중요):**
    * InnoDB는 '넥스트 키락(갭락)'을 지원한다.
    * 만약 UPDATE나 DELETE 문이 **적절한 인덱스를 사용하지 못하면**, 테이블의 **불필요하게 많은 레코드(최악의 경우 모든 레코드)를 잠글(Lock) 수 있다.**
    * 따라서 InnoDB에서는 올바른 인덱스 설계가 매우 중요하다.

### 8.3.4. B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스의 효율성은 여러 요소에 의해 결정된다.

#### 1. 인덱스 키 값의 크기

인덱스를 구성하는 **키(컬럼)의 크기는 가능한 한 작게** 만드는 것이 좋다.
* **페이지(Page):** InnoDB는 디스크 I/O의 최소 단위인 '페이지'(보통 16KB)에 인덱스 정보를 저장한다.
* **저장 효율:** 인덱스 키 값이 작을수록 **하나의 페이지에 더 많은 인덱스 키를 저장**할 수 있다.
* **성능 영향:**
    * 페이지당 저장되는 키가 많아지면 B-Tree의 '깊이'가 얕아져(낮아져) 디스크 I/O 횟수가 줄어든다.
    * 키 값이 너무 크면 메모리(버퍼 풀) 효율이 떨어져 성능이 저하된다.

#### 2. B-Tree 깊이

**B-Tree의 깊이가 깊어질수록 검색 속도가 느려진다.**
* **원인:** B-Tree의 깊이는 인덱스 키의 크기와 총 레코드 건수에 의해 결정된다. 키 값이 크거나 레코드 건수가 많아지면 트리의 깊이가 깊어질 수 있다.
* **성능 영향:** 깊이가 4가 되면 3일 때보다 디스크 I/O가 한 번 더 발생하며, 이는 랜덤 I/O이므로 성능에 직접적인 영향을 준다.
* **참고:** 일반적으로 대용량 데이터베이스라도 B-Tree의 깊이가 5 이상까지 깊어지는 경우는 흔치 않다.

#### 3. 선택도 (기수성)

**선택도(Selectivity) 또는 기수성(Cardinality)은 인덱스 키 값의 유니크한 정도**를 의미하며, **선택도가 높을수록(중복이 적을수록) 검색 효율이 좋다.**
* **선택도 높음 (Good):** 전체 100개 레코드 중 유니크한 값이 100개인 경우 (예: emp_no, jumin_no). 검색 시 대상이 즉시 좁혀진다.
* **선택도 낮음 (Bad):** 전체 100개 레코드 중 유니크한 값이 2개인 경우 (예: gender). 인덱스를 타도 여전히 50개의 레코드를 더 읽어야 하므로 비효율적이다.
* **예외:** 선택도가 낮더라도 **정렬(ORDER BY)이나 그룹핑(GROUP BY) 작업**을 위해서는 인덱스를 만드는 것이 유리할 수 있다.

#### 4. 읽어야 하는 레코드의 건수

인덱스를 사용하는 것이 테이블 전체를 읽는 것(Full Table Scan)보다 항상 빠른 것은 아니다.
* **인덱스의 비용:** 인덱스를 통해 레코드 1건을 읽는 것은 B-Tree 탐색(랜덤 I/O)이 필요하므로, 테이블에서 직접 1건을 읽는 것(시퀀셜 I/O)보다 **약 4~5배 더 비싼 작업**이다.
* **손익 분기점 (Break-Even Point):**
    * DB 옵티마이저가 인덱스를 통해 읽어야 할 레코드의 건수가 **전체 테이블의 약 20~25%를 초과**한다고 판단하면, 인덱스를 이용하는 것보다 **Full Table Scan**이 더 효율적이라고 판단한다.
    * **예시:** 100만 건의 데이터 중 50만 건을 읽어야 한다면, 이는 50%에 해당하므로 옵티마이저는 인덱스를 사용하지 않고 테이블 전체를 스캔한다. (이때 강제로 인덱스를 사용하도록 힌트를 줘도 성능상 이점이 없다.)

### 8.3.5. B-Tree 인덱스를 통한 데이터 읽기 방식

MySQL이 인덱스를 이용해 데이터를 읽는 방식은 크게 4가지로 구분된다.

#### 1. 인덱스 레인지 스캔 (Index Range Scan)

가장 대표적이고 빠른 인덱스 접근 방식으로, 인덱스의 **특정 범위**를 스캔한다.
* **읽기 과정 (3단계):**
    1.  **인덱스 탐색 (Index Seek):** WHERE 조건에 맞는 첫 번째 레코드의 위치를 B-Tree 탐색으로 찾는다.
    2.  **인덱스 스캔 (Index Scan):** 찾은 위치부터 B-Tree 리프 노드의 연결 리스트(Linked List)를 따라 필요한 만큼 순차적으로 읽는다.
    3.  **데이터 읽기 (Table Access):** 인덱스에서 읽은 레코드 주소(PK 또는 ROWID)를 이용해 실제 데이터 파일에서 최종 레코드를 가져온다.
* **커버링 인덱스 (Covering Index):**
    * 만약 쿼리가 필요로 하는 모든 컬럼이 인덱스에 포함되어 있다면, 3번 과정(데이터 읽기)을 생략하고 2번 과정(인덱스 스캔)만으로 처리가 완료된다.
    * 이 경우 디스크의 랜덤 I/O가 크게 줄어들어 성능이 매우 향상된다.

#### 2. 인덱스 풀 스캔 (Index Full Scan)

인덱스 레인지 스캔과 달리 인덱스의 **처음부터 끝까지 전체를 읽는** 방식이다.
* **사용 시점:**
    * 일반적으로 쿼리의 조건절이 다중 컬럼 인덱스의 첫 번째 컬럼이 아닐 때 사용된다. (예: (A, B, C) 인덱스에서 WHERE B='...')
    * 이때 옵티마이저는 A 컬럼을 건너뛸 수 없어 인덱스 전체를 스캔한다.
* **특징:**
    * 테이블 전체를 스캔하는 것(Full Table Scan)보다는 인덱스 파일의 크기가 작으므로 더 효율적일 수 있다.
    * 하지만 인덱스 레인지 스캔보다는 느리다.

#### 3. 루스 인덱스 스캔 (Loose Index Scan)

인덱스 스캔 시 **연속적이지 않은(느슨한) 위치**의 데이터를 건너뛰며 읽는 방식이다.
* **사용 시점:** 주로 GROUP BY 또는 MIN(), MAX() 같은 집합 함수의 최적화에 사용된다.
* **작동:** 인덱스에서 GROUP BY 대상 컬럼의 첫 번째 레코드만 읽고, 동일 그룹의 나머지 레코드는 스킵한 뒤 다음 그룹의 첫 번째 레코드로 이동하는 식으로 작동한다.

#### 4. 인덱스 스킵 스캔 (Index Skip Scan)

MySQL 8.0부터 도입된 최적화 기능이다.
* **핵심:** 다중 컬럼 인덱스에서 **첫 번째 컬럼(선행 컬럼)이 WHERE 조건에 없어도** 옵티마이저가 해당 인덱스를 사용할 수 있게 해준다.
* **예시:** INDEX(gender, birth_date)가 있을 때, 이전 버전에서는 WHERE birth_date='...' 쿼리는 인덱스를 활용하지 못했다. (인덱스 풀 스캔 사용)
* **작동 원리:**
    1.  옵티마이저가 누락된 선행 컬럼(gender)의 **유니크한 값(Distinct Value)**을 먼저 파악한다. (예: 'M', 'F')
    2.  마치 WHERE 조건에 해당 값을 추가한 것처럼 여러 개의 쿼리로 나누어 실행한다.
        * `WHERE gender='M' AND birth_date='...'`
        * `WHERE gender='F' AND birth_date='...'`
    3.  각각의 쿼리가 **인덱스 레인지 스캔**으로 작동하여 결과를 병합한다.
* **제약 조건:** 이 기능은 누락된 **선행 컬럼의 유니크한 값의 개수(Cardinality)가 적을 때만** 효율적으로 작동한다. 유니크한 값이 너무 많으면(예: emp_no), 스캔해야 할 범위가 너무 많아져 오히려 비효율적일 수 있다.

### 8.3.6. B-Tree 인덱스의 가용성과 효율성

B-Tree 인덱스를 효율적으로 사용하기 위해서는 **인덱스 컬럼의 순서**와 **WHERE 조건의 형태**가 매우 중요하다.

#### 1. 인덱스 컬럼 순서의 중요성 (작업 범위 결정 vs. 필터링)

인덱스 컬럼의 순서에 따라 쿼리 효율이 극명하게 달라진다.
* **비교 쿼리:** `WHERE dept_no='d002' AND emp_no>=10114`
* **케이스 A: INDEX(dept_no, emp_no) (효율적 👍)**
    * `dept_no` (선행 컬럼)가 **'작업 범위 결정 조건'**으로 사용된다.
    * `emp_no` (후행 컬럼)도 **'작업 범위 결정 조건'**으로 사용된다.
    * **작동 방식:** 인덱스에서 `dept_no`가 'd002'이면서 `emp_no`가 10114 이상인 지점을 찾은 후, `dept_no`가 'd002'가 아닐 때까지만 스캔한다. 매우 효율적이다.
* **케이스 B: INDEX(emp_no, dept_no) (비효율적 👎)**
    * `emp_no` (선행 컬럼)만 **'작업 범위 결정 조건'**으로 사용된다.
    * `dept_no` (후행 컬럼)는 **'필터링 조건'(체크 조건)**으로만 작동한다.
    * **작동 방식:** 인덱스에서 `emp_no`가 10114 이상인 *모든* 레코드를 먼저 찾은 다음, 이 레코드들을 *일일이* `dept_no`가 'd002'인지 검사한다. 불필요한 비교가 많아 비효율적이다.

#### 2. 핵심 원칙: "왼쪽 값 규칙" (Left-most Prefix Rule)

B-Tree 인덱스의 가장 중요한 특징은 **항상 왼쪽 컬럼을 기준으로 먼저 정렬**된다는 것이다.
* 다중 컬럼 인덱스(예: (col_1, col_2))에서 선행 컬럼(col_1)의 조건 없이는 후행 컬럼(col_2)만으로 인덱스를 효율적으로(레인지 스캔) 사용할 수 없다.
* **예시 1 (사용 불가):** `INDEX(first_name)`가 있을 때
    * `WHERE first_name LIKE '%mer'`
    * 인덱스는 왼쪽부터(Left-most) 비교해야 하는데, 선행 문자가 `%` 와일드카드라 인덱스 레인지 스캔이 불가능하다.
* **예시 2 (사용 불가):** `INDEX(dept_no, emp_no)`가 있을 때
    * `WHERE emp_no=10144`
    * 선행 컬럼인 `dept_no`에 대한 조건이 없으므로, `emp_no`만으로는 인덱스를 효율적으로 사용할 수 없다. (단, 8.3.5절의 '인덱스 스킵 스캔'이 가능한 경우는 예외)

#### 3. 인덱스 사용이 불가능한 (비효율적인) 조건

다음 조건들은 B-Tree의 정렬 특성을 활용할 수 없어 '작업 범위 결정 조건'으로 사용될 수 없다.
* NOT EQUAL 비교 (`<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`)
* LIKE의 선행 와일드카드 (`'%...'` 또는 `'_...'`)
* 인덱스 컬럼의 **변형** (함수 사용, 산술 연산 등)
    * 예: `WHERE SUBSTRING(column, 1, 1) = 'X'`
    * 예: `WHERE DAYOFMONTH(column) = 1`
* 비교되는 값과 **데이터 타입**이 다른 경우 (내부적으로 형변환 발생)
* 문자열 컬럼의 **Collation**(정렬 규칙)이 다른 경우

#### 4. 다중 컬럼 인덱스 활용 패턴

다중 컬럼 인덱스 `INDEX (col_1, col_2, col_3, col_4)`가 있을 때, 인덱스의 '작업 범위 결정'에 사용되는 컬럼은 **항상 선행 컬럼부터 연속적**이어야 한다.
* `=`, `IN` 같은 **동등 비교**는 다음 컬럼으로 **연속**된다.
* `>`, `<`, `BETWEEN`, `LIKE 'prefix...'` 같은 **범위 비교**는 그 **지점에서 연속이 중단**된다.

**활용 예시:**
* **O (Full 사용):** `WHERE col_1=1 AND col_2=2 AND col_3=3 AND col_4=4`
    * `col_1`, `col_2`, `col_3`, `col_4` 모두 범위 결정에 사용된다.
* **O (일부 사용):** `WHERE col_1=1 AND col_2 IN (10,20) AND col_3 <= 10`
    * `col_1` (동등), `col_2` (동등), `col_3` (범위)까지 범위 결정에 사용된다.
* **△ (일부 사용):** `WHERE col_1=1 AND col_2 > 10 AND col_3 = 30`
    * `col_1` (동등), `col_2` (범위)까지만 범위 결정에 사용된다.
    * `col_3`는 범위 조건인 `col_2` 뒤에 나오므로 '필터링 조건'으로만 사용된다.
* **X (사용 불가):** `WHERE col_2 > 10`
    * 선행 컬럼인 `col_1`이 없으므로 인덱스를 효율적으로 사용할 수 없다. (인덱스 스킵 스캔 예외)
* **X (사용 불가):** `WHERE col_1 <> 2`
    * `col_1` 조건이 `NOT EQUAL`이므로 범위 결정에 사용할 수 없다.
