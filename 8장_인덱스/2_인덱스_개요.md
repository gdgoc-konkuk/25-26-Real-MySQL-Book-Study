## 8.2. 인덱스란

인덱스는 데이터베이스 테이블의 **검색 속도를 높이기 위한 자료 구조**이다.

* **비유:** 책의 맨 뒤에 있는 '찾아보기'(색인)와 같다. 책의 내용 전체를 다 뒤지지 않고, 찾아보기를 통해 원하는 내용이 몇 페이지에 있는지 바로 알 수 있다.
* **작동 원리:** 인덱스는 특정 칼럼(들)의 **값**과 해당 레코드가 저장된 **주소**를 `(Key, Value)` 쌍으로 저장한다.
* **핵심 특징: 정렬:** 책의 찾아보기가 '가나다' 순으로 정렬되어 있듯이, DBMS의 인덱스도 칼럼의 값을 미리 **정렬된 상태로 보관**한다.

### 인덱스의 핵심 트레이드오프

인덱스를 프로그래밍 자료 구조에 비유하면 다음과 같다.

* **인덱스 (Index):** `SortedList`와 유사하다. 값이 항상 정렬된 상태로 유지된다.
* **데이터 파일 (Table):** `ArrayList`와 유사하다. 값이 저장된 순서 그대로 유지된다.

이로 인해 다음과 같은 장단점이 발생한다.

* **장점: 읽기(SELECT) 속도 향상**
    이미 정렬된 데이터를 가지고 있기 때문에, `SELECT` 쿼리로 원하는 데이터를 매우 빠르게 찾아올 수 있다.

* **단점: 쓰기(INSERT, UPDATE, DELETE) 속도 저하**
    데이터가 저장, 수정, 삭제될 때마다 인덱스도 항상 정렬된 상태를 유지해야 하므로 추가 작업이 필요해 처리가 느려진다.

**결론:** 인덱스는 데이터의 **저장(쓰기) 성능을 희생**하고, 그 대신 데이터의 **읽기 속도를 높이는** 기능이다. 따라서 `WHERE` 절에 사용되는 칼럼이라고 무조건 인덱스를 생성하면, 저장 성능이 떨어지고 인덱스 크기가 비대해져 오히려 역효과가 날 수 있다.

### 인덱스의 종류

인덱스는 여러 기준으로 분류할 수 있다.

* **역할별 분류**
    * **프라이머리 키 (Primary Key):**
        * 레코드를 대표하고 식별할 수 있는 유일한 기준값(식별자)이다.
        * **NULL 값**을 허용하지 않으며 **중복**을 허용하지 않는다.
    * **보조 키 (Secondary Index):**
        * 프라이머리 키를 제외한 모든 인덱스를 의미한다.
* **저장 방식 (알고리즘)별 분류**
    * **B-Tree 인덱스:**
        * 가장 일반적이고 보편적으로 사용되는 알고리즘이다. (MySQL의 R-Tree 같은 공간 검색도 B-Tree의 응용으로 볼 수 있다.)
    * **Hash 인덱스:**
        * 칼럼의 값으로 해시값을 계산해 인덱싱한다.
        * **매우 빠른 검색**을 지원하지만, 값을 변형하므로 **범위 검색**(`BETWEEN`, `>`)이나 **전방 일치 검색**(`LIKE 'abc%'`)에는 사용할 수 없다. (주로 메모리 기반 DB에서 사용)
* **데이터 중복 허용 여부별 분류**
    * **유니크 인덱스 (Unique Index):**
        * 중복된 값을 허용하지 않는다.
        * 옵티마이저가 이 인덱스로 **동등 조건(`=`)** 검색 시, **1건의 레코드만 찾으면 즉시 검색을 멈출 수 있다**는 것을 알게 되어 효율적이다.
    * **논유니크 인덱스 (Non-Unique Index):**
        * 중복된 값을 허용한다.
* **기능별 분류**
    * **전문 검색용 인덱스 (Full-Text Search Index)**
    * **공간 검색용 인덱스 (Spatial Index)**
