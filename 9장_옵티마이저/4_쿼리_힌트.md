# 9.4. 쿼리 힌트
MySQL 서버는 우리가 서비스 하는 비즈니스를 100% 이해하지 못한다. 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야할지 알려줄 수 있는 방법으로 **힌트**를 사용한다. MySQL 서버에서 사용가능한 쿼리 힌트는 다음과 같이 2가지로 구분할 수 있다.
- 인덱스 힌트
- 옵티마이저 힌트

## 9.4.1. 인덱스 힌트
### STRAIGHT_JOIN
`STRAIGHT_JOIN` 은  옵티마이저 힌트인 동시에 조인 키워드이기도하다. `STRAIGHT_JOIN` 은 `SELECT`, `UPDATE`, `DELETE` 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.

```sql
EXPLAIN
SELECT *
FROM employees e, dept_emp de, departments d
WHERE e.emp_no=de.emp_no AND d.dept_no=de.dept_no;
```

이 쿼리를 실제로 실행해보면 departments 드라이빙 테이블로 선택했고, 두번째로 dept_emp 테이블을 읽은 뒤에 마지막으로 employees를 읽는다.  이유를 추론하면 departments의 아이템 개수가 가장 작기 때문이라고 한다. 

`STRAIGHT_JOIN` 을 쓰면 이 쿼리의 조인 순서를 강제로 변경할 수 있다. 
```sql
SELECT STRAIGHT_JOIN e.first_name, e.last_name, d.dept_name
FROM employees e, dept_emp de, departments d
WHERE e.emp_no=de.emp_no AND d.dept_no=de.dept_no;
```

`STRAIGHT_JOIN`  쿼리의 위치는 `SELECT` 바로 뒤에 존재한다. 위치는 고정이니까 변경 불가능.

`STRAIGHT_JOIN`  힌트는 옵티마이저가 `FROM` 절에서 명시한 테이블의 순서대로 조인을 수행하도록 유도한다.

주로 다음과 같은 상황에서 쓴다.
- 임시 테이블과 일반 테이블의 조인
  - 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다. 
- 임시 테이블 끼리 조인
  - 항상 인덱스가 없기 때문에 어느 테이블을 읽어도 무관하므로 프로그래머가 작은 테이블을 드라이빙 인덱스로 설정해주는 것이 좋다.
- 일반 테이블 끼리 조인
  - 인덱스가 있다면 일반 테이블끼리 조인할때는 옵티마이저가 대부분 적절한 조인 순서를 선택하기 때문에 쿼리를 작성할 때부터 쓸 필요는 없다. 심각한 성능 저하가 있을때 쓰면된다.
  - 양쪽 모두 인덱스가 없는 경우에는 레코드 건 수가 적은 곳으로 드라이빙을 선택해주는 것이 좋다.
  - 양쪽 모두 인덱스가 있다면, 조인 칼럼에 인덱스가 없는 쪽을 드라이빙 테이블로 선택해 주는 것이 좋다.

### USE INDEX, FORCE INDEX, IGNORE INDEX
STRAIGHT_JOIN  과는 다르게 인덱스를 가지는 테이블 뒤에 힌트를 명시해야한다.
대체로 MySQL 옵티마이저는 인덱스를 잘 설정하지만, 3~4개 이상의 칼럼을 포함한 인덱스가 여러 개 존재한다면 옵티마이저가 실수를 하는데 이때 강제로 특정 인덱스를 사용하도록 한다.

# 인덱스 힌트 종류
MySQL에서 제공하는 인덱스 힌트는 옵티마이저의 인덱스 선택에 개입할 수 있게 해준다. 각 힌트는 테이블 이름 뒤에 명시하며, 용도에 따라 다음과 같이 구분된다.
### USE INDEX
USE INDEX는 MySQL 옵티마이저에게 **특정 인덱스를 사용하도록 권장**하는 힌트다. 강제성은 없으며, 옵티마이저가 더 나은 선택지가 있다고 판단하면 다른 인덱스를 선택할 수도 있다.
```sql
SELECT *
FROM employees USE INDEX (ix_firstname)
WHERE first_name='Matt';
```
옵티마이저에게 ix_firstname 인덱스를 **가급적 사용하라고 제안**하는 것이다. 하지만 풀 테이블 스캔이 더 효율적이라고 판단되면 힌트를 무시할 수 있다.
### FORCE INDEX
FORCE INDEX는 USE INDEX보다 **강제성이 강한** 힌트다. MySQL 옵티마이저에게 특정 인덱스를 **반드시 사용하도록 강제**한다.
```sql
SELECT *
FROM employees FORCE INDEX (ix_firstname)
WHERE first_name='Matt';
```
옵티마이저가 ix_firstname 인덱스를 **거의 무조건 사용**하게 된다. 다만 물리적으로 불가능한 경우(예: 인덱스가 쿼리 조건과 전혀 관련 없는 경우)가 아니라면 지정된 인덱스를 사용한다.
### IGNORE INDEX
IGNORE INDEX는 **특정 인덱스를 사용하지 않도록** 옵티마이저에게 지시하는 힌트다. 특정 인덱스가 오히려 성능을 저하시킬 때 유용하다.
```sql
SELECT *
FROM employees IGNORE INDEX (ix_firstname)
WHERE first_name='Matt' AND emp_no BETWEEN 10001 AND 20000;
```
옵티마이저가 ix_firstname 인덱스를 **절대 사용하지 않고**, 다른 가용한 인덱스나 풀 테이블 스캔 중에서 선택하게 된다.
### 인덱스 힌트 용도 지정
각 인덱스 힌트는 **용도를 명시**할 수 있다:
* FOR JOIN: 조인과 레코드 검색을 위한 인덱스
* FOR ORDER BY: ORDER BY 절을 위한 인덱스
* FOR GROUP BY: GROUP BY 절을 위한 인덱스

```sql
SELECT *
FROM employees USE INDEX FOR JOIN (ix_firstname)
WHERE first_name='Matt';
```
```sql
SELECT *
FROM employees USE INDEX FOR ORDER BY (ix_firstname)
WHERE emp_no > 10000
ORDER BY first_name;
```
용도를 명시하지 않으면 기본적으로 FOR JOIN으로 동작한다.
### 사용 시 주의사항
* **USE INDEX vs FORCE INDEX**: 대부분의 경우 USE INDEX로 충분하다. FORCE INDEX는 옵티마이저의 판단을 거의 무시하므로 신중하게 사용해야 한다.
* **인덱스 이름 변경 문제**: 인덱스 힌트는 인덱스 이름에 의존하므로, 인덱스 이름이 변경되면 쿼리가 에러를 발생시키거나 의도와 다르게 동작할 수 있다.
* **옵티마이저 발전**: MySQL 버전이 올라가면서 옵티마이저가 발전하고 있어, 과거에 필요했던 힌트가 불필요해질 수 있다. 정기적으로 힌트의 필요성을 재검토하는 것이 좋다.
* **과도한 사용 지양**: 인덱스 힌트는 최후의 수단이다. 먼저 인덱스 설계, 쿼리 구조, 통계 정보 갱신 등을 점검하고, 그래도 문제가 해결되지 않을 때 사용하는 것이 바람직하다.

## 옵티마이저 힌트
MySQL 8.0부터 도입된 옵티마이저 힌트는 /*+ 힌트명 */ 형태로 SELECT 바로 뒤에 작성한다.

### SET_VAR - 세션 변수 임시 조정
**특정 쿼리 실행 시에만 세션 변수를 일시적으로 변경**한다. 쿼리 종료 후 자동으로 원래 값으로 복원된다.
```sql
SELECT /*+ SET_VAR(sort_buffer_size=262144) */ *
FROM products
ORDER BY price DESC;
```
**주요 활용**
* 대용량 정렬 시 sort_buffer_size 증가
* 복잡한 조인 시 join_buffer_size 조정
* 임시 테이블 크기 조정
⠀전역 설정을 건드리지 않고 특정 쿼리만 튜닝할 수 있어 안전하다.

### MAX_EXECUTION_TIME - 쿼리 시간 제한
**쿼리 최대 실행 시간을 밀리초 단위로 제한**한다. 초과 시 자동 중단.
```sql
SELECT /*+ MAX_EXECUTION_TIME(3000) */ *
FROM logs
WHERE level='ERROR';
```
**주요 활용**
* 잘못된 조건으로 인한 무한 루프형 쿼리 방지
* API 타임아웃 대응
* SELECT 쿼리에만 적용 가능

### JOIN_ORDER / JOIN_FIXED_ORDER - 조인 순서 고정
**테이블 조인 순서를 명시적으로 고정**한다.
```sql
SELECT /*+ JOIN_ORDER(t1, t2, t3) */ *
FROM t1 JOIN t2 ON ... JOIN t3 ON ...;
```
**주요 활용**
* 작은 테이블을 드라이빙 테이블로 강제
* 옵티마이저가 잘못된 순서 선택 시 수정
* JOIN_ORDER는 일부만, JOIN_FIXED_ORDER는 전체 순서 고정

### HASH_JOIN / NO_HASH_JOIN - 해시 조인 제어
**MySQL 8.0.18+ 에서 해시 조인 사용 여부를 제어**한다.
```sql
SELECT /*+ HASH_JOIN(t1, t2) */ *
FROM t1 JOIN t2 ON t1.key = t2.key;
```

**주요 활용**
* 인덱스 없는 컬럼 조인 시 성능 향상
* 대용량 테이블 간 조인
* Nested Loop보다 효율적인 상황에서 강제 적용

### NO_MERGE - 서브쿼리/뷰 병합 방지
**옵티마이저가 서브쿼리를 외부 쿼리와 병합하는 것을 방지**한다.

```sql
SELECT /*+ NO_MERGE(sub) */ *
FROM (
SELECT * FROM orders
ORDER BY order_date DESC LIMIT 10
) AS sub
WHERE sub.status = 'COMPLETED';
```

**주요 활용**
* LIMIT이 있는 서브쿼리의 의미 보존
* ORDER BY 순서 유지
* GROUP BY 집계 결과를 먼저 만든 후 필터링

⠀병합되면 LIMIT이나 정렬 순서가 의도와 다르게 동작할 때 사용한다.

### 사용 시 주의사항
* EXPLAIN으로 적용 전후 비교 필수
* 대부분의 경우 옵티마이저가 적절한 선택을 하므로 꼭 필요할 때만 사용
* MySQL 버전 업그레이드 시 힌트 재검토 필요
