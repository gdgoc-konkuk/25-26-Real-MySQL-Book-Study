# 4절. ENUM과 SET

### 15.4.1 ENUM

ENUM 타입은 테이블 구조(메타 데이터)에 정의된 목록 중 **하나의 값**만 가질 수 있다.

### 저장 방식 및 매핑

- **저장 공간:**
    - 아이템 개수 **255개 미만**: **1바이트** 사용.
    - 아이템 개수 256개 이상: **2바이트** 사용 (최대 65,535개).
- **매핑 방식:** 테이블 정의 시 나열된 순서대로 **1부터 정수값**이 할당되며, 빈 문자열(`""`)은 0으로 매핑된다.
- **연산:** `ENUM` 컬럼에 숫자 연산(예: `1`)을 수행하면 **내부적으로 저장된 숫자 값**으로 연산된다.

### 정렬(Sorting) 특성

- **정렬 기준:** **매핑된 숫자(정수) 값**을 기준으로 정렬되며, 문자열 알파벳 순서가 아니다.
- **문자열 정렬 시:** `ORDER BY CAST(fd_enum AS CHAR)`를 사용해야 하나, **인덱스 적용을 방해**하므로 권장되지 않는다.
    - **권장:** 테이블 생성 시 **정렬 기준**이 될 순서대로 `ENUM` 문자열을 나열해야 한다.

### 3. 스키마 변경 (ALTER TABLE) 주의사항

- **맨 뒤에 추가:** `ALGORITHM=INSTANT`로 동작하며, 메타데이터만 변경되어 **즉시 완료**된다.
- **중간 삽입 / 순서 변경:** `ALGORITHM=COPY, LOCK=SHARED`로 동작하여 **테이블 리빌드**가 필요하며, **읽기 잠금** 발생에 주의해야 한다.
- **운영 팁:** 가용성을 위해 새로운 아이템은 **항상 ENUM 리스트의 마지막에 추가**하는 것이 좋다.

### 4. 장점: 저장 공간 및 성능

- **디스크 공간 절약:** 문자열 대신 1~2바이트의 공간만 사용하여 데이터 크기를 획기적으로 줄인다.
- **메모리 효율 (InnoDB Buffer Pool):** 데이터 크기가 작으면 **더 많은 레코드를 메모리(버퍼 풀)에 적재**할 수 있어 디스크 I/O를 줄이고 쿼리 성능을 향상시킨다.
- **운영 효율:** 데이터 파일 크기가 작아 백업/복구 시간, 스키마 변경 시간 등이 단축된다.

---

### 15.4.2 SET

SET 타입은 정의된 아이템 중 **1개 이상의 값**을 선택하여 저장할 수 있다.

### 1. 저장 방식 및 매핑

- **내부 저장:** 각 아이템은 2^n 값을 가지며, 선택된 값들이 **BIT-OR 연산**을 거쳐 정수값으로 저장된다.
- **표현 방식:** 여러 개의 값을 입력할 때는 쉼표(`,`)로 구분하여 나열한다.
- **저장 공간:**
    - 아이템 개수 **8개 이하**: **1바이트** 사용.
    - 아이템 개수 9개 이상 16개 이하: **2바이트** 사용. (최대 64개 아이템까지 8바이트 사용 가능)

### 2. 검색 및 인덱스 활용

- **단일 값 검색:** 특정 멤버 포함 여부를 검색할 때는 **`FIND_IN_SET()` 함수**를 사용해야 한다.
    - `FIND_IN_SET()`이나 `LIKE`를 사용하는 쿼리는 **인덱스를 사용할 수 없다.**
- **동등 비교:** `WHERE fd_set='TENNIS,GOLF'`와 같이 **저장된 순서대로 문자열을 나열**해야 정확히 일치하는 레코드를 검색할 수 있다.
- **성능 팁:** `FIND_IN_SET()` 검색이 빈번하다면, SET 타입 컬럼을 **정규화하여 별도의 테이블로 분리**하는 것이 좋다.

```sql
- 'GOLF'를 포함하는 레코드 검색 (인덱스 사용 불가)
SELECT * FROM tb_set WHERE FIND_IN_SET('GOLF', fd_set) >= 1;
```

### 3. 스키마 변경 (ALTER TABLE) 주의사항

- **값 추가/삭제:** `ENUM`과 동일하게 맨 뒤에 추가는 `INSTANT`, 중간 삽입/삭제는 `COPY`가 발생한다.